<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CERENCE SDK - SAMPLE RATE CONVERTER C API: IAudioInputAdapter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="nuan_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CERENCE SDK - SAMPLE RATE CONVERTER C API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">IAudioInputAdapter<div class="ingroups"><a class="el" href="group__nuance__audio.html">nuance_audio</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:_i_audio_input_adapter_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_audio_input_adapter_8h.html">IAudioInputAdapter.h</a></td></tr>
<tr class="memdesc:_i_audio_input_adapter_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio input adapter interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__vtable__nuance__audio___i_audio_input_adapter.html">vtable_nuance_audio_IAudioInputAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio input adapter interface.  <a href="struct__vtable__nuance__audio___i_audio_input_adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga371d069bb0dec4df36441638c56dc23c"><td class="memItemLeft" align="right" valign="top">typedef struct _nuance_audio_IAudioInputAdapter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_input_adapter.html#ga371d069bb0dec4df36441638c56dc23c">nuance_audio_IAudioInputAdapter</a></td></tr>
<tr class="memdesc:ga371d069bb0dec4df36441638c56dc23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio input adapter interface.  <a href="#ga371d069bb0dec4df36441638c56dc23c">More...</a><br /></td></tr>
<tr class="separator:ga371d069bb0dec4df36441638c56dc23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3c731622a95f495ee89a958ac889090"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_input_adapter.html#gaa3c731622a95f495ee89a958ac889090">FUNC_nuance_audio_IAudioInputAdapter_configure</a>) (void *instance, <a class="el" href="group___i_audio_input_adapter_listener.html#ga0e5d4a31d2e7c1f9403942a0c0bad287">nuance_audio_IAudioInputAdapterListener</a> *listener, const LH_CHAR *adapterParams, LH_BOOL interleavedFormat, LH_S32 channelCount, LH_S32 sampleRate, LH_S32 samplesPerChannel)</td></tr>
<tr class="memdesc:gaa3c731622a95f495ee89a958ac889090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the audio input adapter.  <a href="#gaa3c731622a95f495ee89a958ac889090">More...</a><br /></td></tr>
<tr class="separator:gaa3c731622a95f495ee89a958ac889090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a1c093eba6dd07d291a4adbb676333"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_input_adapter.html#ga51a1c093eba6dd07d291a4adbb676333">FUNC_nuance_audio_IAudioInputAdapter_open</a>) (void *instance)</td></tr>
<tr class="memdesc:ga51a1c093eba6dd07d291a4adbb676333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the audio input adapter.  <a href="#ga51a1c093eba6dd07d291a4adbb676333">More...</a><br /></td></tr>
<tr class="separator:ga51a1c093eba6dd07d291a4adbb676333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4afe9a754544052c49d9a8649a51d654"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_input_adapter.html#ga4afe9a754544052c49d9a8649a51d654">FUNC_nuance_audio_IAudioInputAdapter_start</a>) (void *instance)</td></tr>
<tr class="memdesc:ga4afe9a754544052c49d9a8649a51d654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts capturing via the audio input adapter.  <a href="#ga4afe9a754544052c49d9a8649a51d654">More...</a><br /></td></tr>
<tr class="separator:ga4afe9a754544052c49d9a8649a51d654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a245ef699307d61a2d2e0eb55343399"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_input_adapter.html#ga3a245ef699307d61a2d2e0eb55343399">FUNC_nuance_audio_IAudioInputAdapter_stop</a>) (void *instance)</td></tr>
<tr class="memdesc:ga3a245ef699307d61a2d2e0eb55343399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops capturing via the audio input adapter.  <a href="#ga3a245ef699307d61a2d2e0eb55343399">More...</a><br /></td></tr>
<tr class="separator:ga3a245ef699307d61a2d2e0eb55343399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60a0d9b8f22f0afc804bd43beff65289"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_input_adapter.html#ga60a0d9b8f22f0afc804bd43beff65289">FUNC_nuance_audio_IAudioInputAdapter_resume</a>) (void *instance)</td></tr>
<tr class="memdesc:ga60a0d9b8f22f0afc804bd43beff65289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes capturing via the audio input adapter.  <a href="#ga60a0d9b8f22f0afc804bd43beff65289">More...</a><br /></td></tr>
<tr class="separator:ga60a0d9b8f22f0afc804bd43beff65289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab46a565e27d054f3c2317c469854a416"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_input_adapter.html#gab46a565e27d054f3c2317c469854a416">FUNC_nuance_audio_IAudioInputAdapter_close</a>) (void *instance)</td></tr>
<tr class="memdesc:gab46a565e27d054f3c2317c469854a416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the audio input adapter.  <a href="#gab46a565e27d054f3c2317c469854a416">More...</a><br /></td></tr>
<tr class="separator:gab46a565e27d054f3c2317c469854a416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c5330e409d350aef0301b5410bc648f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group___string.html#ga12196915107ed4a429ab567f4118da5e">nuance_common_String</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_input_adapter.html#ga0c5330e409d350aef0301b5410bc648f">FUNC_nuance_audio_IAudioInputAdapter_getErrorText</a>) (const void *instance)</td></tr>
<tr class="memdesc:ga0c5330e409d350aef0301b5410bc648f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a textual description of the last audio input adapter error.  <a href="#ga0c5330e409d350aef0301b5410bc648f">More...</a><br /></td></tr>
<tr class="separator:ga0c5330e409d350aef0301b5410bc648f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba6aaca33ed38d0d08de7ed5828c9338"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_input_adapter.html#gaba6aaca33ed38d0d08de7ed5828c9338">FUNC_nuance_audio_IAudioInputAdapter_destroyAdapter</a>) (void *instance)</td></tr>
<tr class="memdesc:gaba6aaca33ed38d0d08de7ed5828c9338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this audio input adapter instance.  <a href="#gaba6aaca33ed38d0d08de7ed5828c9338">More...</a><br /></td></tr>
<tr class="separator:gaba6aaca33ed38d0d08de7ed5828c9338"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad745be8857b3a17ab29ed1aaebd46d26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i_audio_input_adapter.html#ga371d069bb0dec4df36441638c56dc23c">nuance_audio_IAudioInputAdapter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_input_adapter.html#gad745be8857b3a17ab29ed1aaebd46d26">nuance_audio_IAudioInputAdapter_create</a> (const vtable_nuance_audio_IAudioInputAdapter *cb_interface, void *userData)</td></tr>
<tr class="separator:gad745be8857b3a17ab29ed1aaebd46d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74596af27a19d6bfbcaf85b83b988248"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_input_adapter.html#ga74596af27a19d6bfbcaf85b83b988248">nuance_audio_IAudioInputAdapter_destroy</a> (<a class="el" href="group___i_audio_input_adapter.html#ga371d069bb0dec4df36441638c56dc23c">nuance_audio_IAudioInputAdapter</a> *)</td></tr>
<tr class="separator:ga74596af27a19d6bfbcaf85b83b988248"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga371d069bb0dec4df36441638c56dc23c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _nuance_audio_IAudioInputAdapter <a class="el" href="group___i_audio_input_adapter.html#ga371d069bb0dec4df36441638c56dc23c">nuance_audio_IAudioInputAdapter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Audio input adapter interface. </p>
<p>The implementation of this interface is responsible to realize the adaptation of the SDK's audio framework to a specific audio data source (e.g. audio device, pipe, ..) used in a project.</p>
<p>The adapter implementation is used by the AudioInput audio module to capture audio data from a specific audio data source to the audio framework of the SDK. Therefor the AudioInput uses the IAudioInputAdapter interface to control the audio data source and implements the corresponding IAudioInputAdapterListener interface to retrieve the captured audio data from the adapter. The general procedure is described in the following:</p>
<p>1) The user provides the specific adapter implementation via one of the following options to the AudioInput audio module:</p>
<p>1.1) The user creates an instance of the specific adapter implementation and passes it to the AudioInput module at creation time. After the AudioInput module was destroyed the user also has to destroy the corresponding adapter instance.</p>
<p>1.2) The user registers a specific adapter factory at the AudioManager and configures the identifier of this factory as adapter type in the AudioInput module .json configuration. The AudioInput module uses then the provided adapter factory to create and destroy an instance of this specific adapter.</p>
<p>2) With a call to IAudioInputAdapter::configure() an adapter instance is configured right after its creation and in case a configuration has changed dynamically, right before calling IAudioInputAdapter::open(). The configuration of an adapter (e.g. audio format, etc.) is set in the configuration of the AudioInput module. It is also possible to set adapter specific configuration parameters (e.g. device name, pipe name, etc.) that are passed as a configuration string in json format to the specific adapter.</p>
<p>3) With a call to the IAudioInputAdapter::open() the audio data source represented by the adapter is opened with the parameters configured via the last IAudioInputAdapter::configure(). Depending on the AudioInput module's json configuration, the open is called either when the module becomes connected or whenever a new audio session is started (e.g. when the recognizer is started). Whereas the latter option should be used only to enable alternating playback and capturing when an adapter representing a half-duplex audio device is used.</p>
<p>4) A capturing session is started at the adapter with a call to the IAudioInputAdapter::start() method. This is done by the AudioInput module whenever a new audio session is started (e.g. when the recognizer is started). From now on each captured audio packet in the configured audio format is announced by the adapter to the AudioInput module with a call to its IAudioInputAdapterListener::onAudioDataCaptured() method.</p>
<p>5) In case the adapter does not represent a real audio device, a flow control mechanism has to be implemented by the adapter. Each announcement of a captured audio packet via a call to IAudioInputAdapterListener::onAudioDataCaptured() returns the current flow state of audio framework. In case this state corresponds to WILL_DROP, which means, that the next audio packet would be dropped, the adapter has to pause the announcement of new audio packets until IAudioInputAdapterListener::resume() is called. PLEASE BE AWARE that due to the scheduler it may be that the resume() is called before the adapter has evaluated that the onAudioDataCaptured() has returned flow state WILL_DROP. For that reason the flow control should be realized in the adapter by usage of a semaphore like shown in following example pseudo code:</p>
<p>start():</p><ul>
<li>create resume sema (to guarantee that resume sema has the correct state with each started session) stop():</li>
<li>signal resume sema to unblock capturing thread that potentially waits on blocked resume sema</li>
<li>destroy resume sema resume():</li>
<li>signal resume semaphore to unblock capturing thread capturing thread function():</li>
<li>if onAudioDataCaptured() returned flow state WILL_DROP wait on resume semaphore</li>
</ul>
<p>In case the adapter accesses a real audio device a flow control mechanism should not be implemented, as pausing a real audio device is neither intended nor necessary. So the IAudioInputAdapterListener::resume() method has to return OK immediately.</p>
<p>6) A capturing session is stopped at the adapter with a call to the IAudioInputAdapter::stop() method. This is done by the AudioInput module whenever an audio session is stopped (e.g. when the recognizer is stopped). As of now it is no longer allowed to call the IAudioInputAdapterListener::onAudioDataCaptured() method. Hereinafter, either a capturing session is started anew (see 4.) or the adapter is closed (see 7.).</p>
<p>7) With a call to the IAudioInputAdapter::close() the audio data source represented by the adapter is closed. Depending on the AudioInput module's .json configuration, this happens either when the module becomes disconnected or whenever an audio session is stopped (e.g. when the recognizer is stopped). Whereas the latter option should be used only to enable alternating playback and capturing when an adapter representing a half-duplex audio device is used.</p>
<p>The audio data delivered by the audio adapter have to be 16bit little endian PCM in the format determined by the parameter given to the IAudioInputAdapter::configure() method (interleavedFormat, channelCount, sampleRate, samplesPerChannel). </p>

</div>
</div>
<a class="anchor" id="gaa3c731622a95f495ee89a958ac889090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(* FUNC_nuance_audio_IAudioInputAdapter_configure) (void *instance, <a class="el" href="group___i_audio_input_adapter_listener.html#ga0e5d4a31d2e7c1f9403942a0c0bad287">nuance_audio_IAudioInputAdapterListener</a> *listener, const LH_CHAR *adapterParams, LH_BOOL interleavedFormat, LH_S32 channelCount, LH_S32 sampleRate, LH_S32 samplesPerChannel)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the audio input adapter. </p>
<p>This method configures the adapter with:</p>
<ul>
<li>a listener to announce captured audio packets to the audio framework of the SDK</li>
<li>an adapter specific configuration string parameter in json format</li>
<li>the audio format the adapter shall be opened with</li>
</ul>
<p>This method is called right after an adapter is created and in case a configuration has changed dynamically, right before an adapter open call.</p>
<p>This method may be only called in closed state of the adapter, otherwise an error has to be returned. Also in case a given configuration is not supported an error has to be returned.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">listener</td><td>Listener of this audio input adapter object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adapterParams</td><td>Adapter specific configuration parameter json string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interleavedFormat</td><td>Flag indicating whether audio data shall be in interleaved or non-interleaved format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCount</td><td>Channel count. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>Sample rate in hertz. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samplesPerChannel</td><td>Number of samples per channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga51a1c093eba6dd07d291a4adbb676333"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(* FUNC_nuance_audio_IAudioInputAdapter_open) (void *instance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the audio input adapter. </p>
<p>This method opens the audio data source (e.g. audio device) represented by the audio input adapter with the configuration that was given to the last call of the configure() method.</p>
<p>This method may be only called in closed state of the adapter, otherwise an error has to be returned.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4afe9a754544052c49d9a8649a51d654"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(* FUNC_nuance_audio_IAudioInputAdapter_start) (void *instance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts capturing via the audio input adapter. </p>
<p>Within this method a capturing session has to be started.</p>
<p>From now on each captured audio packet has to be announced in the proper audio format to the listener by calling its IAudioInputAdapterListener::onAudioDataCaptured() method. The captured audio data must be valid until the onAudioDataCaptured() method returns. Audio data of a previous capturing session must not be delivered.</p>
<p>The proper audio format of the audio packet announced is determined by the configured audio format and the fact that the SDK requires audio data in 16 bit little endian PCM format.</p>
<p>This method may be only called to an opened, but stopped adapter, otherwise an error has to be returned.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3a245ef699307d61a2d2e0eb55343399"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(* FUNC_nuance_audio_IAudioInputAdapter_stop) (void *instance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops capturing via the audio input adapter. </p>
<p>Within this method a started capturing session has to be stopped.</p>
<p>After this method is left it is no longer allowed to announce audio data to the listener by calling its IAudioInputAdapterListener::onAudioDataCaptured() method.</p>
<p>This method may be only called in started state of the adapter, otherwise an error has to be returned.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga60a0d9b8f22f0afc804bd43beff65289"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(* FUNC_nuance_audio_IAudioInputAdapter_resume) (void *instance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resumes capturing via the audio input adapter. </p>
<p>This method resumes a started capturing session that was stopped due to flow control.</p>
<p>In case the adapter does not represent a real audio device, a flow control mechanism has to be implemented by the adapter. Each announcement of a captured audio packet via a call to IAudioInputAdapterListener::onAudioDataCaptured() returns the current flow state of the audio framework. In case this state corresponds to WILL_DROP, which means, that the next audio packet would be dropped, the adapter has to pause the announcement of new audio packets until this method is called. PLEASE BE AWARE that due to the scheduler it may be that the resume() is called before the adapter has evaluated that the onAudioDataCaptured() has returned flow state WILL_DROP. For that reason the flow control should be realized in the adapter by usage of a semaphore like shown in following example pseudo code:</p>
<p>start():</p><ul>
<li>create resume sema (to guarantee that resume sema has the correct state with each started session) stop():</li>
<li>signal resume sema to unblock capturing thread that potentially waits on blocked resume sema</li>
<li>destroy resume sema resume():</li>
<li>signal resume semaphore to unblock capturing thread capturing thread function():</li>
<li>if onAudioDataCaptured() returned flow state WILL_DROP wait on resume semaphore</li>
</ul>
<p>In case the adapter accesses a real audio device a flow control mechanism should not be implemented, as pausing a real audio device is neither intended nor necessary. So this method has to return OK immediately.</p>
<p>This method may be only called in started state of the adapter, otherwise an error has to be returned.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab46a565e27d054f3c2317c469854a416"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(* FUNC_nuance_audio_IAudioInputAdapter_close) (void *instance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the audio input adapter. </p>
<p>This method closes the audio data source (e.g. audio device) represented by the audio input adapter</p>
<p>This method may be only called in opened, but stopped state of the adapter, otherwise an error has to be returned.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0c5330e409d350aef0301b5410bc648f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group___string.html#ga12196915107ed4a429ab567f4118da5e">nuance_common_String</a>*(* FUNC_nuance_audio_IAudioInputAdapter_getErrorText) (const void *instance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a textual description of the last audio input adapter error. </p>
<p>If applicable the error description of the audio data source represented by the adapter (e.g. audio device) shall be returned.</p>
<p>In case no last error is available an empty string shall be returned.</p>
<p>It is allowed to call this method in context of the IAudioInputAdapterListener::onAudioDataCaptured() method.</p>
<p>This method may be called in any state of the adapter.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaba6aaca33ed38d0d08de7ed5828c9338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* FUNC_nuance_audio_IAudioInputAdapter_destroyAdapter) (void *instance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this audio input adapter instance. </p>
<p>This method is called in context of the destructor of the AudioInput module and indicates that this audio input adapter instance is no longer required. In case this adapter instance was created via the adapter factory approach it has to be deleted in this context. In case the user has created this instance and passed it to the AudioInput module as parameter at creation time, it may be deleted either directly in this context or by the user after the corresponding AudioInput instance was destroyed. In the latter case this method can be implemented empty.</p>
<p>This method may be only called in closed state of the adapter, otherwise an error has to be returned.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad745be8857b3a17ab29ed1aaebd46d26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i_audio_input_adapter.html#ga371d069bb0dec4df36441638c56dc23c">nuance_audio_IAudioInputAdapter</a>* nuance_audio_IAudioInputAdapter_create </td>
          <td>(</td>
          <td class="paramtype">const vtable_nuance_audio_IAudioInputAdapter *&#160;</td>
          <td class="paramname"><em>cb_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_interface</td><td>struct containing callback functions implemented by the user </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userData</td><td>user data which is passed to each callback function as first parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga74596af27a19d6bfbcaf85b83b988248"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nuance_audio_IAudioInputAdapter_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i_audio_input_adapter.html#ga371d069bb0dec4df36441638c56dc23c">nuance_audio_IAudioInputAdapter</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Cerence SDK, &copy;2020, Cerence, Inc.
</small></address>
</body>
</html>
