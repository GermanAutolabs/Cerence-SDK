<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CERENCE SDK - AUDIO SEGMENTATION C API: IAudioOutputAdapter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="nuan_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CERENCE SDK - AUDIO SEGMENTATION C API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">IAudioOutputAdapter<div class="ingroups"><a class="el" href="group__nuance__audio.html">nuance_audio</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:_i_audio_output_adapter_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_audio_output_adapter_8h.html">IAudioOutputAdapter.h</a></td></tr>
<tr class="memdesc:_i_audio_output_adapter_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio output adapter interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__vtable__nuance__audio___i_audio_output_adapter.html">vtable_nuance_audio_IAudioOutputAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio output adapter interface.  <a href="struct__vtable__nuance__audio___i_audio_output_adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga769d2b83f2baddf29241c3ebbd6a4ed8"><td class="memItemLeft" align="right" valign="top">typedef struct _nuance_audio_IAudioOutputAdapter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_output_adapter.html#ga769d2b83f2baddf29241c3ebbd6a4ed8">nuance_audio_IAudioOutputAdapter</a></td></tr>
<tr class="memdesc:ga769d2b83f2baddf29241c3ebbd6a4ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio output adapter interface.  <a href="#ga769d2b83f2baddf29241c3ebbd6a4ed8">More...</a><br /></td></tr>
<tr class="separator:ga769d2b83f2baddf29241c3ebbd6a4ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ce57f661d53d547404a1bcacccaf08c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_output_adapter.html#ga5ce57f661d53d547404a1bcacccaf08c">FUNC_nuance_audio_IAudioOutputAdapter_configure</a>) (void *instance, <a class="el" href="group___i_audio_output_adapter_listener.html#ga04233aca3b46fb2b3c9e6fef65f7085d">nuance_audio_IAudioOutputAdapterListener</a> *listener, const LH_CHAR *adapterParams, LH_BOOL interleavedFormat, LH_S32 channelCount, LH_S32 sampleRate, LH_S32 samplesPerChannel, LH_S32 bufferCount, const LH_CHAR *audioDataType)</td></tr>
<tr class="memdesc:ga5ce57f661d53d547404a1bcacccaf08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the audio output adapter.  <a href="#ga5ce57f661d53d547404a1bcacccaf08c">More...</a><br /></td></tr>
<tr class="separator:ga5ce57f661d53d547404a1bcacccaf08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc7a218778f5b905c49df780a2f5ff2f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_output_adapter.html#gadc7a218778f5b905c49df780a2f5ff2f">FUNC_nuance_audio_IAudioOutputAdapter_open</a>) (void *instance)</td></tr>
<tr class="memdesc:gadc7a218778f5b905c49df780a2f5ff2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the audio output adapter.  <a href="#gadc7a218778f5b905c49df780a2f5ff2f">More...</a><br /></td></tr>
<tr class="separator:gadc7a218778f5b905c49df780a2f5ff2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd6d72b8453c79892e4a37661c6b8ebb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_output_adapter.html#gadd6d72b8453c79892e4a37661c6b8ebb">FUNC_nuance_audio_IAudioOutputAdapter_write</a>) (void *instance, LH_S16 const *audioData, LH_S32 naudioData)</td></tr>
<tr class="memdesc:gadd6d72b8453c79892e4a37661c6b8ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes audio data for playback to the audio output adapter.  <a href="#gadd6d72b8453c79892e4a37661c6b8ebb">More...</a><br /></td></tr>
<tr class="separator:gadd6d72b8453c79892e4a37661c6b8ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d9950ed2e493907b63c7a373c4c6761"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_output_adapter.html#ga7d9950ed2e493907b63c7a373c4c6761">FUNC_nuance_audio_IAudioOutputAdapter_writeEncoded</a>) (void *instance, LH_S8 const *audioData, LH_S32 naudioData)</td></tr>
<tr class="memdesc:ga7d9950ed2e493907b63c7a373c4c6761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes audio data for playback to the audio output adapter.  <a href="#ga7d9950ed2e493907b63c7a373c4c6761">More...</a><br /></td></tr>
<tr class="separator:ga7d9950ed2e493907b63c7a373c4c6761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5efd99afd769942ad50016ee030434b0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_output_adapter.html#ga5efd99afd769942ad50016ee030434b0">FUNC_nuance_audio_IAudioOutputAdapter_endOfStream</a>) (void *instance)</td></tr>
<tr class="memdesc:ga5efd99afd769942ad50016ee030434b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the end of stream to the audio output adapter.  <a href="#ga5efd99afd769942ad50016ee030434b0">More...</a><br /></td></tr>
<tr class="separator:ga5efd99afd769942ad50016ee030434b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab00d32c979c66620655958c5cfbb9faf"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_output_adapter.html#gab00d32c979c66620655958c5cfbb9faf">FUNC_nuance_audio_IAudioOutputAdapter_abort</a>) (void *instance)</td></tr>
<tr class="memdesc:gab00d32c979c66620655958c5cfbb9faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the playback of the audio output adapter.  <a href="#gab00d32c979c66620655958c5cfbb9faf">More...</a><br /></td></tr>
<tr class="separator:gab00d32c979c66620655958c5cfbb9faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1994c93cfb41cf17473c40ac0c6c9620"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_output_adapter.html#ga1994c93cfb41cf17473c40ac0c6c9620">FUNC_nuance_audio_IAudioOutputAdapter_close</a>) (void *instance)</td></tr>
<tr class="memdesc:ga1994c93cfb41cf17473c40ac0c6c9620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the audio output adapter.  <a href="#ga1994c93cfb41cf17473c40ac0c6c9620">More...</a><br /></td></tr>
<tr class="separator:ga1994c93cfb41cf17473c40ac0c6c9620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78b924c2d37d9b173247564ad0a55b35"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group___string.html#ga12196915107ed4a429ab567f4118da5e">nuance_common_String</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_output_adapter.html#ga78b924c2d37d9b173247564ad0a55b35">FUNC_nuance_audio_IAudioOutputAdapter_getErrorText</a>) (const void *instance)</td></tr>
<tr class="memdesc:ga78b924c2d37d9b173247564ad0a55b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a textual description of the last audio output adapter error.  <a href="#ga78b924c2d37d9b173247564ad0a55b35">More...</a><br /></td></tr>
<tr class="separator:ga78b924c2d37d9b173247564ad0a55b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b5987a60702a88682e1a5761683e04f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_output_adapter.html#ga9b5987a60702a88682e1a5761683e04f">FUNC_nuance_audio_IAudioOutputAdapter_destroyAdapter</a>) (void *instance)</td></tr>
<tr class="memdesc:ga9b5987a60702a88682e1a5761683e04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this audio output adapter instance.  <a href="#ga9b5987a60702a88682e1a5761683e04f">More...</a><br /></td></tr>
<tr class="separator:ga9b5987a60702a88682e1a5761683e04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac2cdd2455dd30c655b8d1e5561325469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i_audio_output_adapter.html#ga769d2b83f2baddf29241c3ebbd6a4ed8">nuance_audio_IAudioOutputAdapter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_output_adapter.html#gac2cdd2455dd30c655b8d1e5561325469">nuance_audio_IAudioOutputAdapter_create</a> (const vtable_nuance_audio_IAudioOutputAdapter *cb_interface, void *userData)</td></tr>
<tr class="separator:gac2cdd2455dd30c655b8d1e5561325469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9f81557e344e105b59f6cbf48d652c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_audio_output_adapter.html#gaf9f81557e344e105b59f6cbf48d652c2">nuance_audio_IAudioOutputAdapter_destroy</a> (<a class="el" href="group___i_audio_output_adapter.html#ga769d2b83f2baddf29241c3ebbd6a4ed8">nuance_audio_IAudioOutputAdapter</a> *)</td></tr>
<tr class="separator:gaf9f81557e344e105b59f6cbf48d652c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga769d2b83f2baddf29241c3ebbd6a4ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _nuance_audio_IAudioOutputAdapter <a class="el" href="group___i_audio_output_adapter.html#ga769d2b83f2baddf29241c3ebbd6a4ed8">nuance_audio_IAudioOutputAdapter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Audio output adapter interface. </p>
<p>The implementation of this interface is responsible to realize the adaptation of the SDK's audio framework to a specific audio data sink (e.g. audio device, pipe, ..) used in a project.</p>
<p>The adapter implementation is used by the AudioOutput audio module to play back audio data via a specific audio data sink. Therefor the AudioOutput module uses the IAudioOutputAdapter interface to control the audio data sink and implements the corresponding IAudioOutputAdapterListener interface to retrieve the information when an audio package was played out by the adapter. The general procedure is described in the following:</p>
<p>1) The user provides the specific adapter implementation via one of the following options to the AudioOutput audio module:</p>
<p>1.1) The user creates an instance of the specific adapter implementation and passes it to the AudioOutput module at creation time. After the AudioOutput module was destroyed the user also has to destroy the corresponding adapter instance.</p>
<p>1.2) The user registers a specific adapter factory at the AudioManager and configures the identifier of this factory as adapter type in the AudioOutput module .json configuration. The AudioOutput module uses then the provided adapter factory to create and destroy an instance of this specific adapter.</p>
<p>2) With a call to IAudioOutputAdapter::configure() an adapter instance is configured right after its creation and in case a configuration has changed dynamically, right before calling IAudioOutputAdapter::open(). The configuration of an adapter (e.g. audio format, etc.) is set in the configuration of the AudioOutput module. It is also possible to set adapter specific configuration parameters (e.g. device name, pipe name, etc.) that are passed as a configuration string in json format to the specific adapter.</p>
<p>3) With a call to the IAudioOutputAdapter::open() the audio data sink represented by the adapter is opened with the parameters via the last IAudioOutputAdapter::configure(). Depending on the AudioOutput module's json configuration, the open is called when the module becomes connected or whenever an audio stream is started (e.g. with each begin of stream indication of a prompt). Whereas the latter option is used only to enable alternating playback and capturing when an adapter representing a half-duplex audio device is used.</p>
<p>4) A playback session is started with the first call to the IAudioOutputAdapter::write() method, followed by subsequent write() calls and ending with a call to IAudioOutputAdapter::endOfData() resp. IAudioOutputAdapter:: abort(). Each audio packet written to the adapter is confirmed to the AudioOuput module as soon as it is played out resp. when the playback process is aborted.</p>
<p>5) With a call to the IAudioOutputAdapter::close() the audio data sink represented by the adapter is closed. Depending on the AudioOutput module's .json configuration, this happens either when the module becomes disconnected or whenever an audio stream is finished (e.g. with each end of stream indication of a prompt). Whereas the latter option is used only to enable alternating playback and capturing when an adapter representing a half-duplex audio device is used.</p>
<p>The audio data delivered by the audio adapter have to be 8bit encoded or 16bit little endian PCM in the format determined by the parameter given to the IAudioOutputAdapter::configure() method (interleavedFormat, channelCount, sampleRate, samplesPerChannel, audioDataType). </p>

</div>
</div>
<a class="anchor" id="ga5ce57f661d53d547404a1bcacccaf08c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(* FUNC_nuance_audio_IAudioOutputAdapter_configure) (void *instance, <a class="el" href="group___i_audio_output_adapter_listener.html#ga04233aca3b46fb2b3c9e6fef65f7085d">nuance_audio_IAudioOutputAdapterListener</a> *listener, const LH_CHAR *adapterParams, LH_BOOL interleavedFormat, LH_S32 channelCount, LH_S32 sampleRate, LH_S32 samplesPerChannel, LH_S32 bufferCount, const LH_CHAR *audioDataType)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the audio output adapter. </p>
<p>This method configures the adapter with:</p>
<ul>
<li>a listener to confirm each played out resp. aborted audio packet to the SDK's audio framework</li>
<li>an adapter specific configuration string parameter in json format</li>
<li>the audio format and buffer count the adapter shall be opened with</li>
</ul>
<p>This method is called right after an adapter is created and in case a configuration has changed dynamically, right before an adapter open call.</p>
<p>This method may be only called in closed state of the adapter, otherwise an error has to be returned. Also in case a given configuration is not supported an error has to be returned.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">listener</td><td>Listener of this audio output adapter object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adapterParams</td><td>Adapter specific configuration parameter json string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interleavedFormat</td><td>Flag indicating whether audio data shall be in interleaved or non-interleaved format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channelCount</td><td>Channel count. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleRate</td><td>Sample rate in hertz. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samplesPerChannel</td><td>Number of samples per channel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferCount</td><td>Number of audio buffers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">audioDataType</td><td>Type of the audio data shall be 8bit encoded or 16bit PCM. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadc7a218778f5b905c49df780a2f5ff2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(* FUNC_nuance_audio_IAudioOutputAdapter_open) (void *instance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the audio output adapter. </p>
<p>This method opens the audio data sink (e.g. audio device) represented by the audio output adapter with the configuration that was given to the last call of the configure() method.</p>
<p>This method may be only called in closed state of the adapter, otherwise an error has to be returned.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadd6d72b8453c79892e4a37661c6b8ebb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(* FUNC_nuance_audio_IAudioOutputAdapter_write) (void *instance, LH_S16 const *audioData, LH_S32 naudioData)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes audio data for playback to the audio output adapter. </p>
<p>PLEASE NOTE that it is a severe requirement to implement this function in a non-blocking and short-running manner. It is not allowed to perform any time consuming actions like for instance writing the audio data to a file system or calling a blocking write function of an audio device driver in this context. This means, that the processing of the audio data must be decoupled to not block the caller of this function. This can be reached by enqueuing the given audio packet to a playback buffer queue on which another thread context performs the processing. Thereby the playback queue must be able to hold at maximum bufferCount audio packets, each with a maximum sample size of channelCount multiplied with the samplesPerChannel value. In case the maximum number of audio packets resp. the maximum audio packet size exceeds, this method may not block but has to return an error.</p>
<p>The audio format of the audio data is determined by the configured audio format. This method is called only if the audioDataType is PCM16, then the SDK's audio framework provides audio data in 16 bit little endian PCM format.</p>
<p>Mandatorily each audio data package given to this method has to be confirmed with calling the IAudioOutputAdapterListener::onAudioDataPlayed() as soon as the package is played out resp. when the playback is aborted. Thereby the order of confirmations has to correspond the order the audio packages were written to the adapter. The confirmation mechanism is used by the AudioOutput module to implement a flow control to not exceed the playback buffer queue of the adapter.</p>
<p>Each given audio package is valid until it is confirmed to the AudioOutput module and thus should not be copied without a need.</p>
<p>This method may be only called in opened state of the adapter, otherwise an error has to be returned.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">audioData</td><td>AudioData object containing audio data for playback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">naudioData</td><td>Number of elements in audioData </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7d9950ed2e493907b63c7a373c4c6761"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(* FUNC_nuance_audio_IAudioOutputAdapter_writeEncoded) (void *instance, LH_S8 const *audioData, LH_S32 naudioData)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes audio data for playback to the audio output adapter. </p>
<p>PLEASE NOTE that it is a severe requirement to implement this function in a non-blocking and short-running manner. It is not allowed to perform any time consuming actions like for instance writing the audio data to a file system or calling a blocking write function of an audio device driver in this context. This means, that the processing of the audio data must be decoupled to not block the caller of this function. This can be reached by enqueuing the given audio packet to a playback buffer queue on which another thread context performs the processing. Thereby the playback queue must be able to hold at maximum bufferCount audio packets, each with a maximum sample size of channelCount multiplied with the samplesPerChannel value. In case the maximum number of audio packets resp. the maximum audio packet size exceeds, this method may not block but has to return an error.</p>
<p>The audio format of the audio data is determined by the configured audio format. This method is called only if the audioDataType is not PCM16.</p>
<p>Mandatorily each audio data package given to this method has to be confirmed with calling the IAudioOutputAdapterListener::onAudioDataPlayed() as soon as the package is played out resp. when the playback is aborted. Thereby the order of confirmations has to correspond the order the audio packages were written to the adapter. The confirmation mechanism is used by the AudioOutput module to implement a flow control to not exceed the playback buffer queue of the adapter.</p>
<p>Each given audio package is valid until it is confirmed to the AudioOutput module and thus should not be copied without a need.</p>
<p>This method may be only called in opened state of the adapter, otherwise an error has to be returned.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">audioData</td><td>AudioData object containing audio data for playback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">naudioData</td><td>Number of elements in audioData </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5efd99afd769942ad50016ee030434b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(* FUNC_nuance_audio_IAudioOutputAdapter_endOfStream) (void *instance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the end of stream to the audio output adapter. </p>
<p>This method is called after writing the last audio data of an audio stream to the audio output adapter. This means that all enqueued audio data packages have to be played out and confirmed at the AudioOutput module with calling the IAudioOutputAdapterListener::onAudioDataPlayed().</p>
<p>PLEASE NOTE that it is a severe requirement to implement this function in a non-blocking and short-running manner. It is not allowed to perform any time consuming actions like for instance waiting until all enqueued audio packets are played out.</p>
<p>This method may be only called after at least one audio packet was written to the audio output adapter, otherwise an error has to be returned.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab00d32c979c66620655958c5cfbb9faf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(* FUNC_nuance_audio_IAudioOutputAdapter_abort) (void *instance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the playback of the audio output adapter. </p>
<p>Within this method a running playback session must be stopped immediately at the represented audio data sink (e.g. audio output device). The playback buffer of the audio output device has to be cleared and all audio packets handed so far to the adapter must be confirmed at the AudioOutput module with calling the IAudioOutputAdapterListener::onAudioDataPlayed() before this method returns.</p>
<p>This method may be called in any state. In case currently no playback is running or the playback is already finished the method may not return an error.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1994c93cfb41cf17473c40ac0c6c9620"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group___result_code.html#ga2ea6a3cbb3f672e03e57207386536641">nuance_common_ResultCode</a>(* FUNC_nuance_audio_IAudioOutputAdapter_close) (void *instance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the audio output adapter. </p>
<p>This method closes the audio data sink (e.g. audio device) represented by the audio output adapter</p>
<p>This method may be only called in opened state of the adapter, otherwise an error has to be returned.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga78b924c2d37d9b173247564ad0a55b35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group___string.html#ga12196915107ed4a429ab567f4118da5e">nuance_common_String</a>*(* FUNC_nuance_audio_IAudioOutputAdapter_getErrorText) (const void *instance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a textual description of the last audio output adapter error. </p>
<p>If applicable the error description of the audio data sink represented by the adapter (e.g. audio device) shall be returned.</p>
<p>In case no last error is available an empty string shall be returned.</p>
<p>It is allowed to call this method in context of the IAudioOutputAdapterListener::onAudioDataPlayed() method.</p>
<p>This method may be called in any state of the adapter.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9b5987a60702a88682e1a5761683e04f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* FUNC_nuance_audio_IAudioOutputAdapter_destroyAdapter) (void *instance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this audio output adapter instance. </p>
<p>This method is called in context of the destructor of the AudioOutput module and indicates that this audio output adapter instance is no longer required. In case this adapter instance was created via the adapter factory approach it has to be deleted in this context. In case the user has created this instance and passed it to the AudioOutput module as parameter at creation time, it may be deleted either directly in this context or by the user after the corresponding AudioOutput instance was destroyed. In the latter case this method can be implemented empty.</p>
<p>This method may be only called in closed state of the adapter, otherwise an error has to be returned.</p>
<p>This method doesn't have to be thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">instance</td><td>The instance pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac2cdd2455dd30c655b8d1e5561325469"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i_audio_output_adapter.html#ga769d2b83f2baddf29241c3ebbd6a4ed8">nuance_audio_IAudioOutputAdapter</a>* nuance_audio_IAudioOutputAdapter_create </td>
          <td>(</td>
          <td class="paramtype">const vtable_nuance_audio_IAudioOutputAdapter *&#160;</td>
          <td class="paramname"><em>cb_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_interface</td><td>struct containing callback functions implemented by the user </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userData</td><td>user data which is passed to each callback function as first parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf9f81557e344e105b59f6cbf48d652c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nuance_audio_IAudioOutputAdapter_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i_audio_output_adapter.html#ga769d2b83f2baddf29241c3ebbd6a4ed8">nuance_audio_IAudioOutputAdapter</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Cerence SDK, &copy;2020, Cerence, Inc.
</small></address>
</body>
</html>
